###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       16/Oct/2019  19:52:56
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Github\razor_sam3u2\firmware_common\drivers\buttons.c
#    Command line =  
#        -f C:\Users\JoeyD\AppData\Local\Temp\EW30A8.tmp
#        (C:\Github\razor_sam3u2\firmware_common\drivers\buttons.c -D EIE_ASCII
#        --preprocess=cs
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\Debug\List -lC
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\Debug\List -o
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\ -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\bsp\ -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\drivers\ -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\application\ -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\..\firmware_common\
#        -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\..\firmware_common\application\
#        -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\..\firmware_common\bsp\
#        -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\Debug\List\buttons.lst
#    Object file  =  
#        C:\Github\razor_sam3u2\firmware_ascii\iar_8_10_1\Debug\Obj\buttons.o
#
###############################################################################

C:\Github\razor_sam3u2\firmware_common\drivers\buttons.c
      1          /*!**********************************************************************************************************************
      2          @file buttons.c                                                                
      3          @brief Button functions and state machine.  
      4          
      5          The application handles all debouncing and button press / hold detection.
      6          All buttons use interrupts to trigger the start and end
      7          of the action.
      8          
      9          ------------------------------------------------------------------------------------------------------------------------
     10          GLOBALS
     11          - NONE
     12          
     13          CONSTANTS
     14          - U32_DEBOUNCE_TIME
     15          
     16          TYPES
     17          - enum ButtonStateType
     18          - struct ButtonStatusType
     19          
     20          PUBLIC FUNCTIONS
     21          - bool IsButtonPressed(ButtonNameType eButton_)
     22          - bool WasButtonPressed(ButtonNameType eButton_)
     23          - void ButtonAcknowledge(ButtonNameType eButton_)
     24          - bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
     25          
     26          PROTECTED FUNCTIONS
     27          - void ButtonInitialize(void)
     28          - void ButtonRunActiveState(void)
     29          - void ButtonStartDebounce(u32 u32BitPosition_, PortOffsetType ePort_)
     30          
     31          
     32          ***********************************************************************************************************************/
     33          
     34          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   00000006   0x408A             LSLS     R2,R2,R1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0003             MOVS     R3,R0
   \   00000010   0x095B             LSRS     R3,R3,#+5
   \   00000012   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   00000006   0x408A             LSLS     R2,R2,R1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0003             MOVS     R3,R0
   \   00000010   0x095B             LSRS     R3,R3,#+5
   \   00000012   0xF841 0x2023      STR      R2,[R1, R3, LSL #+2]
   \   00000016   0x4770             BX       LR               ;; return
     35          
     36          
     37          /***********************************************************************************************************************
     38          Global variable definitions with scope across entire project.
     39          All Global variable names shall start with "G_<type>Button"
     40          ***********************************************************************************************************************/
     41          /* New variables */
     42          
     43          /*--------------------------------------------------------------------------------------------------------------------*/
     44          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     45          extern volatile u32 G_u32SystemTime1ms;                     /*!< @brief From main.c */
     46          extern volatile u32 G_u32SystemTime1s;                      /*!< @brief From main.c */
     47          extern volatile u32 G_u32SystemFlags;                       /*!< @brief From main.c */
     48          extern volatile u32 G_u32ApplicationFlags;                  /*!< @brief From main.c */
     49          
     50          extern const PinConfigurationType G_asBspButtonConfigurations[U8_TOTAL_BUTTONS]; /*!< @brief from board-specific file */
     51          
     52          
     53          /***********************************************************************************************************************
     54          Global variable definitions with scope limited to this local application.
     55          Variable names shall start with "Button_<type>" and be declared as static.
     56          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     57          static fnCode_type Button_pfnStateMachine;                  /*!< @brief The Button application state machine function pointer */
   \                     Button_pfnStateMachine:
   \   00000000                      DS8 4
     58          

   \                                 In section .bss, align 4
     59          static ButtonStatusType Button_asStatus[U8_TOTAL_BUTTONS];  /*!< @brief Individual status parameters for buttons */
   \                     Button_asStatus:
   \   00000000                      DS8 48
     60          
     61          
     62          /***********************************************************************************************************************
     63          Function Definitions
     64          ***********************************************************************************************************************/
     65          
     66          /*------------------------------------------------------------------------------------------------------------------*/
     67          /*! @publicsection */                                                                                            
     68          /*--------------------------------------------------------------------------------------------------------------------*/
     69          
     70          /*!----------------------------------------------------------------------------------------------------------------------
     71          @fn bool IsButtonPressed(ButtonNameType eButton_)
     72          
     73          @brief Determine if a particular button is currently pressed at the moment in time when 
     74          the function is called.
     75          
     76          The button must still be pressed at the time of this inquiry for the function
     77          to return TRUE.
     78          
     79          Requires:
     80          - Button_asStatus[eButton_] is a valid index
     81          
     82          @param eButton_ is a valid button 
     83           
     84          Promises:
     85          - Returns TRUE if Button_asStatus[eButton_].eCurrentState is PRESSED 
     86          - Otherwise returns FALSE
     87          
     88          */

   \                                 In section .text, align 2, keep-with-next
     89          bool IsButtonPressed(ButtonNameType eButton_)
     90          {
   \                     IsButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     91            if( Button_asStatus[(u8)eButton_].eCurrentState == PRESSED)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x220C             MOVS     R2,#+12
   \   0000000A   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000000E   0x4410             ADD      R0,R0,R2
   \   00000010   0x7880             LDRB     R0,[R0, #+2]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD101             BNE.N    ??IsButtonPressed_0
     92            {
     93              return(TRUE);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??IsButtonPressed_1
     94            }
     95            else
     96            {
     97              return(FALSE);
   \                     ??IsButtonPressed_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??IsButtonPressed_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
     98            }
     99          
    100          } /* end IsButtonPressed() */
    101          
    102          
    103          /*!----------------------------------------------------------------------------------------------------------------------
    104          @fn bool WasButtonPressed(ButtonNameType eButton_)
    105          
    106          @brief Determines if a particular button was pressed since last time it was checked. 
    107          
    108          This is effectively a latching function so that button presses are
    109          not missed and are potentially available to multiple tasks.
    110          
    111          The button may or may not still be pressed when this inquiry is made.  Mulitple
    112          button presses are not tracked.  The user should call ButtonAcknowledge immediately
    113          following this function to clear the state. If multiple tasks need the button 
    114          information, only the last function should call ButtonAcknowledge.
    115          
    116          Requires:
    117          - Button_asStatus[eButton_] is a valid index
    118          
    119          @param eButton_ is a valid button 
    120           
    121          Promises:
    122          - Returns TRUE if Button_asStatus[eButton_].bNewPressFlag is TRUE 
    123          - Otherwise returns FALSE
    124          
    125          */

   \                                 In section .text, align 2, keep-with-next
    126          bool WasButtonPressed(ButtonNameType eButton_)
    127          {
   \                     WasButtonPressed: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    128            if( Button_asStatus[(u8)eButton_].bNewPressFlag == TRUE)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x220C             MOVS     R2,#+12
   \   0000000A   0xFB02 0xF201      MUL      R2,R2,R1
   \   0000000E   0x4410             ADD      R0,R0,R2
   \   00000010   0x7840             LDRB     R0,[R0, #+1]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD101             BNE.N    ??WasButtonPressed_0
    129            {
    130              return(TRUE);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??WasButtonPressed_1
    131            }
    132            else
    133            {
    134              return(FALSE);
   \                     ??WasButtonPressed_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??WasButtonPressed_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    135            }
    136          
    137          } /* end WasButtonPressed() */
    138          
    139          
    140          /*!----------------------------------------------------------------------------------------------------------------------
    141          @fn void ButtonAcknowledge(ButtonNameType eButton_)
    142          
    143          @brief Clears the "New Press" flag of a button so WasButtonPressed() no longer returns TRUE
    144          unless a new button press occurs.
    145          
    146          This function is generally always called after WasButtonPressed() returns TRUE unless 
    147          it is known that other tasks may need the button pressed information.
    148          
    149          Requires:
    150          @param eButton_ is a valid button index
    151           
    152          Promises:
    153          - The flag at Button_asStatus[eButton_].bNewPressFlag is set to FALSE
    154          
    155          */

   \                                 In section .text, align 2, keep-with-next
    156          void ButtonAcknowledge(ButtonNameType eButton_)
    157          {
    158            Button_asStatus[(u8)eButton_].bNewPressFlag = FALSE;
   \                     ButtonAcknowledge: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable10_2
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x230C             MOVS     R3,#+12
   \   00000008   0xFB03 0xF300      MUL      R3,R3,R0
   \   0000000C   0x441A             ADD      R2,R2,R3
   \   0000000E   0x7051             STRB     R1,[R2, #+1]
    159          
    160          } /* end ButtonAcknowledge() */
   \   00000010   0x4770             BX       LR               ;; return
    161          
    162          
    163          /*!----------------------------------------------------------------------------------------------------------------------
    164          @fn bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
    165          
    166          @brief Queries to see if a button has been held for a certain time.  
    167          
    168          The button must still be pressed when this function is called if it is to return TRUE.
    169          This is a non-latching function.
    170          
    171          Requires:
    172          @param eButton_ is a valid button index
    173          @param u32ButtonHeldTime_ is a time in ms 
    174           
    175          Promises:
    176          - Returns TRUE if eButton_ has been held longer than u32ButtonHeldTime_
    177          - Otherwise returns FALSE
    178          
    179          */

   \                                 In section .text, align 2, keep-with-next
    180          bool IsButtonHeld(ButtonNameType eButton_, u32 u32ButtonHeldTime_)
    181          {
   \                     IsButtonHeld: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    182           if( (Button_asStatus[(u8)eButton_].eCurrentState == PRESSED) && 
    183                IsTimeUp(&Button_asStatus[eButton_].u32DebounceTimeStart, u32ButtonHeldTime_ ) )
   \   00000006   0x....             LDR.N    R0,??DataTable10_2
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x210C             MOVS     R1,#+12
   \   0000000C   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000010   0x4408             ADD      R0,R0,R1
   \   00000012   0x7880             LDRB     R0,[R0, #+2]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD10D             BNE.N    ??IsButtonHeld_0
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x....             LDR.N    R0,??DataTable10_2
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x220C             MOVS     R2,#+12
   \   00000020   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000024   0x4410             ADD      R0,R0,R2
   \   00000026   0x1D00             ADDS     R0,R0,#+4
   \   00000028   0x.... 0x....      BL       IsTimeUp
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ.N    ??IsButtonHeld_0
    184           {
    185             return(TRUE);
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE000             B.N      ??IsButtonHeld_1
    186           }
    187           else
    188           {
    189             return(FALSE);
   \                     ??IsButtonHeld_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??IsButtonHeld_1: (+1)
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    190           }
    191          
    192          } /* end IsButtonHeld() */
    193          
    194          
    195          /*------------------------------------------------------------------------------------------------------------------*/
    196          /*! @protectedsection */                                                                                            
    197          /*--------------------------------------------------------------------------------------------------------------------*/
    198          
    199          /*!----------------------------------------------------------------------------------------------------------------------
    200          @fn void ButtonInitialize(void)
    201          
    202          @brief Runs required initialization for the task.  
    203          
    204          Should only be called once in main init section.
    205          
    206          
    207          Requires:
    208          - NONE
    209           
    210          Promises:
    211          - The Button task is configured
    212          - Button interrupts are active on PIOA and PIOB
    213          - Button task is set to ButtonSM_Idle
    214          
    215          */

   \                                 In section .text, align 2, keep-with-next
    216          void ButtonInitialize(void)
    217          {
   \                     ButtonInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    218            u32 u32Dummy;
    219            
    220            /* Setup default data for all of the buttons in the system */
    221            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \   00000002   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_0: (+1)
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xDA30             BGE.N    ??ButtonInitialize_1
    222            {
    223              Button_asStatus[i].bDebounceActive = FALSE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x....             LDR.N    R2,??DataTable10_2
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x230C             MOVS     R3,#+12
   \   00000012   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000016   0x54D1             STRB     R1,[R2, R3]
    224              Button_asStatus[i].bNewPressFlag = FALSE;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x....             LDR.N    R2,??DataTable10_2
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x230C             MOVS     R3,#+12
   \   00000020   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000024   0x441A             ADD      R2,R2,R3
   \   00000026   0x7051             STRB     R1,[R2, #+1]
    225              Button_asStatus[i].eCurrentState = RELEASED;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x....             LDR.N    R2,??DataTable10_2
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x230C             MOVS     R3,#+12
   \   00000030   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000034   0x441A             ADD      R2,R2,R3
   \   00000036   0x7091             STRB     R1,[R2, #+2]
    226              Button_asStatus[i].eNewState     = RELEASED;
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x....             LDR.N    R2,??DataTable10_2
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x230C             MOVS     R3,#+12
   \   00000040   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000044   0x441A             ADD      R2,R2,R3
   \   00000046   0x70D1             STRB     R1,[R2, #+3]
    227              Button_asStatus[i].u32TimeStamp  = 0;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x....             LDR.N    R2,??DataTable10_2
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x230C             MOVS     R3,#+12
   \   00000050   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000054   0x441A             ADD      R2,R2,R3
   \   00000056   0x6091             STR      R1,[R2, #+8]
    228              Button_asStatus[i].u32DebounceTimeStart = 0;    
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x....             LDR.N    R2,??DataTable10_2
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x230C             MOVS     R3,#+12
   \   00000060   0xFB03 0xF300      MUL      R3,R3,R0
   \   00000064   0x441A             ADD      R2,R2,R3
   \   00000066   0x6051             STR      R1,[R2, #+4]
    229            }
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0xE7CB             B.N      ??ButtonInitialize_0
    230          
    231            /* Enable PIO interrupts */
    232            AT91C_BASE_PIOA->PIO_IER = GPIOA_BUTTONS;
   \                     ??ButtonInitialize_1: (+1)
   \   0000006C   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000070   0x....             LDR.N    R1,??DataTable10_3  ;; 0x400e0c40
   \   00000072   0x6008             STR      R0,[R1, #+0]
    233            AT91C_BASE_PIOB->PIO_IER = GPIOB_BUTTONS;
   \   00000074   0x2007             MOVS     R0,#+7
   \   00000076   0x....             LDR.N    R1,??DataTable10_4  ;; 0x400e0e40
   \   00000078   0x6008             STR      R0,[R1, #+0]
    234            
    235            /* Dummy code to read the ISR registers and clear the flags */
    236            u32Dummy  = AT91C_BASE_PIOA->PIO_ISR;
   \   0000007A   0x....             LDR.N    R0,??DataTable10_5  ;; 0x400e0c4c
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x0004             MOVS     R4,R0
    237            u32Dummy |= AT91C_BASE_PIOB->PIO_ISR;
   \   00000080   0x....             LDR.N    R0,??DataTable10_6  ;; 0x400e0e4c
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x4304             ORRS     R4,R0,R4
    238          
    239            /* Configure the NVIC to ensure the PIOA and PIOB interrupts are active */
    240            NVIC_ClearPendingIRQ(IRQn_PIOA);
   \   00000086   0x200A             MOVS     R0,#+10
   \   00000088   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    241            NVIC_ClearPendingIRQ(IRQn_PIOB);
   \   0000008C   0x200B             MOVS     R0,#+11
   \   0000008E   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    242            NVIC_EnableIRQ(IRQn_PIOA);
   \   00000092   0x200A             MOVS     R0,#+10
   \   00000094   0x.... 0x....      BL       NVIC_EnableIRQ
    243            NVIC_EnableIRQ(IRQn_PIOB);
   \   00000098   0x200B             MOVS     R0,#+11
   \   0000009A   0x.... 0x....      BL       NVIC_EnableIRQ
    244              
    245            /* Init complete: set function pointer and application flag */
    246            Button_pfnStateMachine = ButtonSM_Idle;
   \   0000009E   0x.... 0x....      ADR.W    R0,ButtonSM_Idle
   \   000000A2   0x....             LDR.N    R1,??DataTable10_7
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    247            G_u32ApplicationFlags |= _APPLICATION_FLAGS_BUTTON;
   \   000000A6   0x....             LDR.N    R0,??DataTable10_8
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000AE   0x....             LDR.N    R1,??DataTable10_8
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    248            DebugPrintf("Button task ready\n\r");
   \   000000B2   0x....             LDR.N    R0,??DataTable10_9
   \   000000B4   0x.... 0x....      BL       DebugPrintf
    249          
    250          } /* end ButtonInitialize() */
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    251          
    252          
    253          /*!----------------------------------------------------------------------------------------------------------------------
    254          @fn ButtonRunActiveState()
    255          
    256          @brief Selects and runs one iteration of the current state in the state machine.
    257          
    258          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    259          may take 1ms / n to execute.
    260          
    261          Requires:
    262            - State machine function pointer points at current state
    263          
    264          Promises:
    265            - Calls the function to pointed by the state machine function pointer
    266          */

   \                                 In section .text, align 2, keep-with-next
    267          void ButtonRunActiveState(void)
    268          {
   \                     ButtonRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    269            Button_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable10_7
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    270          
    271          } /* end ButtonRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    272          
    273          
    274          /*!----------------------------------------------------------------------------------------------------------------------
    275          @fn void ButtonStartDebounce(u32 u32BitPosition_, PortOffsetType ePort_)
    276          
    277          @brief Called only from ISR: sets the "debounce active" flag and debounce start time  
    278          
    279          Requires:
    280          - Only the PIOA or PIOB ISR should call this function
    281          
    282          @param u32BitPosition_ is a SINGLE bit and actual button location on which to start debouncing
    283          @param ePort_ is the port on which the button is located
    284          
    285          Promises:
    286          - If the indicated button is found in G_asBspButtonConfigurations, then the
    287          corresponding interrupt is disabled and debounce information is set in Button_asStatus
    288          
    289          */

   \                                 In section .text, align 2, keep-with-next
    290          void ButtonStartDebounce(u32 u32BitPosition_, PortOffsetType ePort_)
    291          {
   \                     ButtonStartDebounce: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    292            ButtonNameType eButton = NOBUTTON;
   \   00000002   0x2204             MOVS     R2,#+4
    293            
    294            /* Parse through to find the button */
    295            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \   00000004   0x2300             MOVS     R3,#+0
   \                     ??ButtonStartDebounce_0: (+1)
   \   00000006   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000008   0x2B04             CMP      R3,#+4
   \   0000000A   0xDA12             BGE.N    ??ButtonStartDebounce_1
    296            {
    297              if( (G_asBspButtonConfigurations[i].u32BitPosition == u32BitPosition_) &&
    298                  (G_asBspButtonConfigurations[i].ePort == ePort_) )
   \   0000000C   0x....             LDR.N    R4,??DataTable10_10
   \   0000000E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000010   0xF854 0x4033      LDR      R4,[R4, R3, LSL #+3]
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD10A             BNE.N    ??ButtonStartDebounce_2
   \   00000018   0x....             LDR.N    R4,??DataTable10_10
   \   0000001A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001C   0xEB04 0x04C3      ADD      R4,R4,R3, LSL #+3
   \   00000020   0x7924             LDRB     R4,[R4, #+4]
   \   00000022   0x000D             MOVS     R5,R1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x42AC             CMP      R4,R5
   \   00000028   0xD101             BNE.N    ??ButtonStartDebounce_2
    299              {
    300                eButton = (ButtonNameType)i;
   \   0000002A   0x001A             MOVS     R2,R3
    301                break;
   \   0000002C   0xE001             B.N      ??ButtonStartDebounce_1
    302              }
    303            }
   \                     ??ButtonStartDebounce_2: (+1)
   \   0000002E   0x1C5B             ADDS     R3,R3,#+1
   \   00000030   0xE7E9             B.N      ??ButtonStartDebounce_0
    304            
    305            /* If the button has been found, disable the interrupt and update debounce status */
    306            if(eButton != NOBUTTON)
   \                     ??ButtonStartDebounce_1: (+1)
   \   00000032   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000034   0x2A04             CMP      R2,#+4
   \   00000036   0xD014             BEQ.N    ??ButtonStartDebounce_3
    307            {
    308              AT91C_BASE_PIOA->PIO_IDR |= u32BitPosition_;
   \   00000038   0x....             LDR.N    R3,??DataTable10_11  ;; 0x400e0c44
   \   0000003A   0x681B             LDR      R3,[R3, #+0]
   \   0000003C   0x4303             ORRS     R3,R0,R3
   \   0000003E   0x....             LDR.N    R4,??DataTable10_11  ;; 0x400e0c44
   \   00000040   0x6023             STR      R3,[R4, #+0]
    309              Button_asStatus[(u8)eButton].bDebounceActive = TRUE;
   \   00000042   0x2301             MOVS     R3,#+1
   \   00000044   0x....             LDR.N    R4,??DataTable10_2
   \   00000046   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000048   0x250C             MOVS     R5,#+12
   \   0000004A   0xFB05 0xF502      MUL      R5,R5,R2
   \   0000004E   0x5563             STRB     R3,[R4, R5]
    310              Button_asStatus[(u8)eButton].u32DebounceTimeStart = G_u32SystemTime1ms;
   \   00000050   0x....             LDR.N    R3,??DataTable10_12
   \   00000052   0x681B             LDR      R3,[R3, #+0]
   \   00000054   0x....             LDR.N    R4,??DataTable10_2
   \   00000056   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000058   0x250C             MOVS     R5,#+12
   \   0000005A   0xFB05 0xF502      MUL      R5,R5,R2
   \   0000005E   0x442C             ADD      R4,R4,R5
   \   00000060   0x6063             STR      R3,[R4, #+4]
    311            }
    312            
    313          } /* end ButtonStartDebounce() */
   \                     ??ButtonStartDebounce_3: (+1)
   \   00000062   0xBC30             POP      {R4,R5}
   \   00000064   0x4770             BX       LR               ;; return
    314           
    315          
    316          /*------------------------------------------------------------------------------------------------------------------*/
    317          /*! @privatesection */                                                                                            
    318          /*--------------------------------------------------------------------------------------------------------------------*/
    319          
    320          
    321          /***********************************************************************************************************************
    322          State Machine Function Definitions
    323          
    324          The button state machine monitors button activity and manages debouncing and
    325          maintaining the global button states.
    326          ***********************************************************************************************************************/
    327          
    328          /*!-------------------------------------------------------------------------------------------------------------------
    329          @fn static void ButtonSM_Idle(void)
    330          
    331          @brief Look for at least one button to enter debouncing state
    332          */

   \                                 In section .text, align 4, keep-with-next
    333          static void ButtonSM_Idle(void)                
    334          {
    335            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \                     ButtonSM_Idle: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \                     ??ButtonSM_Idle_0: (+1)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xDA0E             BGE.N    ??ButtonSM_Idle_1
    336            {
    337              if(Button_asStatus[i].bDebounceActive)
   \   00000008   0x....             LDR.N    R0,??DataTable10_2
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0xFB02 0xF201      MUL      R2,R2,R1
   \   00000012   0x5C80             LDRB     R0,[R0, R2]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??ButtonSM_Idle_2
    338              {
    339                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   00000018   0x.... 0x....      ADR.W    R0,ButtonSM_ButtonActive
   \   0000001C   0x....             LDR.N    R1,??DataTable10_7
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    340                break;
   \   00000020   0xE001             B.N      ??ButtonSM_Idle_1
    341              }
    342            }
   \                     ??ButtonSM_Idle_2: (+1)
   \   00000022   0x1C49             ADDS     R1,R1,#+1
   \   00000024   0xE7ED             B.N      ??ButtonSM_Idle_0
    343            
    344          } /* end ButtonSM_Idle(void) */
   \                     ??ButtonSM_Idle_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    345          
    346          
    347          /*!-------------------------------------------------------------------------------------------------------------------
    348          @fn static void ButtonSM_ButtonActive(void)
    349          
    350          @brief Process each button that is debouncing.
    351          
    352          Time out the debounce period and set the "pressed" state if button action is confirmed.
    353          Manage the hold timers.
    354          */

   \                                 In section .text, align 4, keep-with-next
    355          static void ButtonSM_ButtonActive(void)         
    356          {
   \                     ButtonSM_ButtonActive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    357            u32 *pu32PortAddress;
    358            u32 *pu32InterruptAddress;
    359          
    360            /* Start by resetting back to Idle in case no buttons are active */
    361            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable10_13
   \   00000004   0x....             LDR.N    R1,??DataTable10_7
   \   00000006   0x6008             STR      R0,[R1, #+0]
    362          
    363            /* Check for buttons that are debouncing */
    364            for(u8 i = 0; i < U8_TOTAL_BUTTONS; i++)
   \   00000008   0x2600             MOVS     R6,#+0
   \                     ??ButtonSM_ButtonActive_0: (+1)
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x2E04             CMP      R6,#+4
   \   0000000E   0xF280 0x80AA      BGE.W    ??ButtonSM_ButtonActive_1
    365            {
    366              /* Load address offsets for the current button */
    367              pu32PortAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_PDSR) + G_asBspButtonConfigurations[i].ePort);
   \   00000012   0x....             LDR.N    R0,??DataTable10_14  ;; 0x400e0c3c
   \   00000014   0x....             LDR.N    R1,??DataTable10_10
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0xEB01 0x01C6      ADD      R1,R1,R6, LSL #+3
   \   0000001C   0x7909             LDRB     R1,[R1, #+4]
   \   0000001E   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000022   0x0004             MOVS     R4,R0
    368              pu32InterruptAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_IER) + G_asBspButtonConfigurations[i].ePort);
   \   00000024   0x....             LDR.N    R0,??DataTable10_3  ;; 0x400e0c40
   \   00000026   0x....             LDR.N    R1,??DataTable10_10
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0xEB01 0x01C6      ADD      R1,R1,R6, LSL #+3
   \   0000002E   0x7909             LDRB     R1,[R1, #+4]
   \   00000030   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000034   0x0005             MOVS     R5,R0
    369              
    370              /* Check if the current button is debouncing */
    371              if( Button_asStatus[i].bDebounceActive )
   \   00000036   0x....             LDR.N    R0,??DataTable10_2
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x210C             MOVS     R1,#+12
   \   0000003C   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000040   0x5C40             LDRB     R0,[R0, R1]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xF000 0x808D      BEQ.W    ??ButtonSM_ButtonActive_2
    372              {
    373                /* Still have an active button */
    374                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   00000048   0x....             LDR.N    R0,??DataTable10_15
   \   0000004A   0x....             LDR.N    R1,??DataTable10_7
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    375                
    376                /* Check if debounce period is over */
    377                if( IsTimeUp(&Button_asStatus[i].u32DebounceTimeStart, U32_DEBOUNCE_TIME) )
   \   0000004E   0x210A             MOVS     R1,#+10
   \   00000050   0x....             LDR.N    R0,??DataTable10_2
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x220C             MOVS     R2,#+12
   \   00000056   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000005A   0x4410             ADD      R0,R0,R2
   \   0000005C   0x1D00             ADDS     R0,R0,#+4
   \   0000005E   0x.... 0x....      BL       IsTimeUp
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD07D             BEQ.N    ??ButtonSM_ButtonActive_2
    378                {
    379                  /* Active low */
    380                  if(G_asBspButtonConfigurations[i].eActiveState == ACTIVE_LOW)
   \   00000066   0x....             LDR.N    R0,??DataTable10_10
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0xEB00 0x00C6      ADD      R0,R0,R6, LSL #+3
   \   0000006E   0x7940             LDRB     R0,[R0, #+5]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD11A             BNE.N    ??ButtonSM_ButtonActive_3
    381                  {
    382                    /* Read PIO_PDSR to get the actual input signal (new button state) */
    383                    if( ~(*pu32PortAddress) & G_asBspButtonConfigurations[i].u32BitPosition )
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x....             LDR.N    R1,??DataTable10_10
   \   00000078   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007A   0xF851 0x1036      LDR      R1,[R1, R6, LSL #+3]
   \   0000007E   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD008             BEQ.N    ??ButtonSM_ButtonActive_4
    384                    {          
    385                      Button_asStatus[i].eNewState = PRESSED;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x....             LDR.N    R1,??DataTable10_2
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0x220C             MOVS     R2,#+12
   \   0000008E   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000092   0x4411             ADD      R1,R1,R2
   \   00000094   0x70C8             STRB     R0,[R1, #+3]
   \   00000096   0xE020             B.N      ??ButtonSM_ButtonActive_5
    386                    }
    387                    else
    388                    {
    389                      Button_asStatus[i].eNewState = RELEASED;
   \                     ??ButtonSM_ButtonActive_4: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x....             LDR.N    R1,??DataTable10_2
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0x220C             MOVS     R2,#+12
   \   000000A0   0xFB02 0xF206      MUL      R2,R2,R6
   \   000000A4   0x4411             ADD      R1,R1,R2
   \   000000A6   0x70C8             STRB     R0,[R1, #+3]
   \   000000A8   0xE017             B.N      ??ButtonSM_ButtonActive_5
    390                    }
    391                  }
    392                  /* Active high */
    393                  else
    394                  {
    395                    /* Read PIO_PDSR to get the actual input signal (new button state) */
    396                    if( *pu32PortAddress & G_asBspButtonConfigurations[i].u32BitPosition )
   \                     ??ButtonSM_ButtonActive_3: (+1)
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x....             LDR.N    R1,??DataTable10_10
   \   000000AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B0   0xF851 0x1036      LDR      R1,[R1, R6, LSL #+3]
   \   000000B4   0x4208             TST      R0,R1
   \   000000B6   0xD008             BEQ.N    ??ButtonSM_ButtonActive_6
    397                    {          
    398                      Button_asStatus[i].eNewState = PRESSED;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x....             LDR.N    R1,??DataTable10_2
   \   000000BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BE   0x220C             MOVS     R2,#+12
   \   000000C0   0xFB02 0xF206      MUL      R2,R2,R6
   \   000000C4   0x4411             ADD      R1,R1,R2
   \   000000C6   0x70C8             STRB     R0,[R1, #+3]
   \   000000C8   0xE007             B.N      ??ButtonSM_ButtonActive_5
    399                    }
    400                    else
    401                    {
    402                      Button_asStatus[i].eNewState = RELEASED;
   \                     ??ButtonSM_ButtonActive_6: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x....             LDR.N    R1,??DataTable10_2
   \   000000CE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D0   0x220C             MOVS     R2,#+12
   \   000000D2   0xFB02 0xF206      MUL      R2,R2,R6
   \   000000D6   0x4411             ADD      R1,R1,R2
   \   000000D8   0x70C8             STRB     R0,[R1, #+3]
    403                    }
    404                  }
    405                  
    406                  /* Update if the button state has changed */
    407                  if( Button_asStatus[i].eNewState != Button_asStatus[i].eCurrentState )
   \                     ??ButtonSM_ButtonActive_5: (+1)
   \   000000DA   0x....             LDR.N    R0,??DataTable10_2
   \   000000DC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DE   0x210C             MOVS     R1,#+12
   \   000000E0   0xFB01 0xF106      MUL      R1,R1,R6
   \   000000E4   0x4408             ADD      R0,R0,R1
   \   000000E6   0x78C0             LDRB     R0,[R0, #+3]
   \   000000E8   0x....             LDR.N    R1,??DataTable10_2
   \   000000EA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EC   0x220C             MOVS     R2,#+12
   \   000000EE   0xFB02 0xF206      MUL      R2,R2,R6
   \   000000F2   0x4411             ADD      R1,R1,R2
   \   000000F4   0x7889             LDRB     R1,[R1, #+2]
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD027             BEQ.N    ??ButtonSM_ButtonActive_7
    408                  {
    409                    Button_asStatus[i].eCurrentState = Button_asStatus[i].eNewState;
   \   000000FA   0x....             LDR.N    R0,??DataTable10_2
   \   000000FC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FE   0x210C             MOVS     R1,#+12
   \   00000100   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000104   0x4408             ADD      R0,R0,R1
   \   00000106   0x78C0             LDRB     R0,[R0, #+3]
   \   00000108   0x....             LDR.N    R1,??DataTable10_2
   \   0000010A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000010C   0x220C             MOVS     R2,#+12
   \   0000010E   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000112   0x4411             ADD      R1,R1,R2
   \   00000114   0x7088             STRB     R0,[R1, #+2]
    410                    
    411                    /* If the new state is PRESSED, update the new press flag */
    412                    if(Button_asStatus[i].eCurrentState == PRESSED)
   \   00000116   0x....             LDR.N    R0,??DataTable10_2
   \   00000118   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000011A   0x210C             MOVS     R1,#+12
   \   0000011C   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000120   0x4408             ADD      R0,R0,R1
   \   00000122   0x7880             LDRB     R0,[R0, #+2]
   \   00000124   0x2801             CMP      R0,#+1
   \   00000126   0xD110             BNE.N    ??ButtonSM_ButtonActive_7
    413                    {
    414                      Button_asStatus[i].bNewPressFlag = TRUE;
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0x....             LDR.N    R1,??DataTable10_2
   \   0000012C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000012E   0x220C             MOVS     R2,#+12
   \   00000130   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000134   0x4411             ADD      R1,R1,R2
   \   00000136   0x7048             STRB     R0,[R1, #+1]
    415                      Button_asStatus[i].u32TimeStamp  = G_u32SystemTime1ms;
   \   00000138   0x....             LDR.N    R0,??DataTable10_12
   \   0000013A   0x6800             LDR      R0,[R0, #+0]
   \   0000013C   0x....             LDR.N    R1,??DataTable10_2
   \   0000013E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000140   0x220C             MOVS     R2,#+12
   \   00000142   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000146   0x4411             ADD      R1,R1,R2
   \   00000148   0x6088             STR      R0,[R1, #+8]
    416                    }
    417                  }
    418          
    419                  /* Regardless of a good press or not, clear the debounce active flag and re-enable the interrupts */
    420                  Button_asStatus[i].bDebounceActive = FALSE;
   \                     ??ButtonSM_ButtonActive_7: (+1)
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x....             LDR.N    R1,??DataTable10_2
   \   0000014E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000150   0x220C             MOVS     R2,#+12
   \   00000152   0xFB02 0xF206      MUL      R2,R2,R6
   \   00000156   0x5488             STRB     R0,[R1, R2]
    421                  *pu32InterruptAddress = G_asBspButtonConfigurations[i].u32BitPosition;
   \   00000158   0x....             LDR.N    R0,??DataTable10_10
   \   0000015A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000015C   0xF850 0x0036      LDR      R0,[R0, R6, LSL #+3]
   \   00000160   0x6028             STR      R0,[R5, #+0]
    422                  
    423                } /* end if( IsTimeUp...) */
    424              } /* end if(Button_asStatus[i].bDebounceActive) */
    425            } /* end for (u8 i = 0; i < U8_TOTAL_BUTTONS; i++) */
   \                     ??ButtonSM_ButtonActive_2: (+1)
   \   00000162   0x1C76             ADDS     R6,R6,#+1
   \   00000164   0xE751             B.N      ??ButtonSM_ButtonActive_0
    426            
    427          } /* end ButtonSM_ButtonActive() */
   \                     ??ButtonSM_ButtonActive_1: (+1)
   \   00000166   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     Button_asStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x400E0C40         DC32     0x400e0c40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400E0E40         DC32     0x400e0e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x400E0C4C         DC32     0x400e0c4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x400E0E4C         DC32     0x400e0e4c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     Button_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     G_asBspButtonConfigurations

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x400E0C44         DC32     0x400e0c44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     ButtonSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x400E0C3C         DC32     0x400e0c3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     ButtonSM_ButtonActive

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x42 0x75          DC8 "Button task ready\012\015"
   \              0x74 0x74    
   \              0x6F 0x6E    
   \              0x20 0x74    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    428          
    429          
    430          #if 0
    431          /*!-------------------------------------------------------------------------------------------------------------------
    432          @fn static void ButtonSM_Error(void)
    433          
    434          @brief Handle an error here.  For now, the task is just held in this state. 
    435          */
    436          static void ButtonSM_Error(void)          
    437          {
    438            
    439          } /* end ButtonSM_Error() */
    440          #endif
    441          
    442          
    443          /*--------------------------------------------------------------------------------------------------------------------*/
    444          /* End of File */
    445          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ButtonAcknowledge
       8   ButtonInitialize
         8   -> DebugPrintf
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_EnableIRQ
       8   ButtonRunActiveState
         8   -- Indirect call
      16   ButtonSM_ButtonActive
        16   -> IsTimeUp
       0   ButtonSM_Idle
       8   ButtonStartDebounce
      16   IsButtonHeld
        16   -> IsTimeUp
       0   IsButtonPressed
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
       0   WasButtonPressed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      20  ?_0
      18  ButtonAcknowledge
     186  ButtonInitialize
      10  ButtonRunActiveState
     360  ButtonSM_ButtonActive
      40  ButtonSM_Idle
     102  ButtonStartDebounce
      48  Button_asStatus
       4  Button_pfnStateMachine
      56  IsButtonHeld
      30  IsButtonPressed
      24  NVIC_ClearPendingIRQ
      24  NVIC_EnableIRQ
      30  WasButtonPressed

 
  52 bytes in section .bss
  20 bytes in section .rodata
 944 bytes in section .text
 
 944 bytes of CODE  memory
  20 bytes of CONST memory
  52 bytes of DATA  memory

Errors: none
Warnings: none
