###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       23/Oct/2019  20:23:16
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Github\EiE\firmware_common\application\user_app1.c
#    Command line =  
#        -f C:\Users\JoeyD\AppData\Local\Temp\EW98EB.tmp
#        (C:\Github\EiE\firmware_common\application\user_app1.c -D EIE_ASCII
#        --preprocess=cs C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\List -lC
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\List -o
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\bsp\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\drivers\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\application\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\application\
#        -I C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\bsp\
#        -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\List\user_app1.lst
#    Object file  =  
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\Obj\user_app1.o
#
###############################################################################

C:\Github\EiE\firmware_common\application\user_app1.c
      1          /*!*********************************************************************************************************************
      2          @file user_app1.c                                                                
      3          @brief User's tasks / applications are written here.  This description
      4          should be replaced by something specific to the task.
      5          
      6          ----------------------------------------------------------------------------------------------------------------------
      7          To start a new task using this user_app1 as a template:
      8           1. Copy both user_app1.c and user_app1.h to the Application directory
      9           2. Rename the files yournewtaskname.c and yournewtaskname.h
     10           3. Add yournewtaskname.c and yournewtaskname.h to the Application Include and Source groups in the IAR project
     11           4. Use ctrl-h (make sure "Match Case" is checked) to find and replace all instances of "user_app1" with "yournewtaskname"
     12           5. Use ctrl-h to find and replace all instances of "UserApp1" with "YourNewTaskName"
     13           6. Use ctrl-h to find and replace all instances of "USER_APP1" with "YOUR_NEW_TASK_NAME"
     14           7. Add a call to YourNewTaskNameInitialize() in the init section of main
     15           8. Add a call to YourNewTaskNameRunActiveState() in the Super Loop section of main
     16           9. Update yournewtaskname.h per the instructions at the top of yournewtaskname.h
     17          10. Include new header file in "configuration.h"
     18          11. Delete this text (between the dashed lines) and update the Description below to describe your task
     19          ----------------------------------------------------------------------------------------------------------------------
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          GLOBALS
     23          - NONE
     24          
     25          CONSTANTS
     26          - NONE
     27          
     28          TYPES
     29          - NONE
     30          
     31          PUBLIC FUNCTIONS
     32          - NONE
     33          
     34          PROTECTED FUNCTIONS
     35          - void UserApp1Initialize(void)
     36          - void UserApp1RunActiveState(void)
     37          
     38          
     39          **********************************************************************************************************************/
     40          
     41          #include "configuration.h"
     42          
     43          /***********************************************************************************************************************
     44          Global variable definitions with scope across entire project.
     45          All Global variable names shall start with "G_<type>UserApp1"
     46          ***********************************************************************************************************************/
     47          /* New variables */

   \                                 In section .bss, align 4
     48          volatile u32 G_u32UserApp1Flags;                          /*!< @brief Global state flags */
   \                     G_u32UserApp1Flags:
   \   00000000                      DS8 4
     49          
     50          
     51          /*--------------------------------------------------------------------------------------------------------------------*/
     52          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     53          extern volatile u32 G_u32SystemTime1ms;                   /*!< @brief From main.c */
     54          extern volatile u32 G_u32SystemTime1s;                    /*!< @brief From main.c */
     55          extern volatile u32 G_u32SystemFlags;                     /*!< @brief From main.c */
     56          extern volatile u32 G_u32ApplicationFlags;                /*!< @brief From main.c */
     57          
     58          
     59          /***********************************************************************************************************************
     60          Global variable definitions with scope limited to this local application.
     61          Variable names shall start with "UserApp1_<type>" and be declared as static.
     62          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     63          static fnCode_type UserApp1_pfStateMachine;               /*!< @brief The state machine function pointer */
   \                     UserApp1_pfStateMachine:
   \   00000000                      DS8 4
     64          //static u32 UserApp1_u32Timeout;                           /*!< @brief Timeout counter used across states */
     65          
     66          
     67          /**********************************************************************************************************************
     68          Function Definitions
     69          **********************************************************************************************************************/
     70          
     71          /*--------------------------------------------------------------------------------------------------------------------*/
     72          /*! @publicsection */                                                                                            
     73          /*--------------------------------------------------------------------------------------------------------------------*/
     74          
     75          /*--------------------------------------------------------------------------------------------------------------------*/
     76          /*! @protectedsection */                                                                                            
     77          /*--------------------------------------------------------------------------------------------------------------------*/
     78          
     79          /*!--------------------------------------------------------------------------------------------------------------------
     80          @fn void UserApp1Initialize(void)
     81          
     82          @brief
     83          Initializes the State Machine and its variables.
     84          
     85          Should only be called once in main init section.
     86          
     87          Requires:
     88          - NONE
     89          
     90          Promises:
     91          - NONE
     92          
     93          */

   \                                 In section .text, align 2, keep-with-next
     94          void UserApp1Initialize(void)
     95          {
   \                     UserApp1Initialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     96            
     97            HEARTBEAT_OFF();
   \   00000002   0xF05F 0x4000      MOVS     R0,#-2147483648
   \   00000006   0x....             LDR.N    R1,??DataTable2  ;; 0x400e0c30
   \   00000008   0x6008             STR      R0,[R1, #+0]
     98            /* If good initialization, set state to Idle */
     99            if( 1 )
    100            {
    101              UserApp1_pfStateMachine = UserApp1SM_Idle;
   \   0000000A   0x.... 0x....      ADR.W    R0,UserApp1SM_Idle
   \   0000000E   0x....             LDR.N    R1,??DataTable2_1
   \   00000010   0x6008             STR      R0,[R1, #+0]
    102            }
    103            else
    104            {
    105              /* The task isn't properly initialized, so shut it down and don't run */
    106              UserApp1_pfStateMachine = UserApp1SM_Error;
    107            }
    108            
    109            /* Initialize all unused LEDs to off */
    110            LedOff(CYAN);
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0x.... 0x....      BL       LedOff
    111            LedOff(GREEN);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x.... 0x....      BL       LedOff
    112            LedOff(YELLOW);
   \   0000001E   0x2005             MOVS     R0,#+5
   \   00000020   0x.... 0x....      BL       LedOff
    113            LedOff(ORANGE);
   \   00000024   0x2006             MOVS     R0,#+6
   \   00000026   0x.... 0x....      BL       LedOff
    114            
    115            /* Turn on desired LEDs using the ON function */
    116            LedOn(BLUE);
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x.... 0x....      BL       LedOn
    117            LedOn(PURPLE);
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       LedOn
    118          
    119            /* Set an LED to blink at 2Hz */
    120            LedBlink(RED, LED_2HZ);
   \   00000036   0x21FA             MOVS     R1,#+250
   \   00000038   0x2007             MOVS     R0,#+7
   \   0000003A   0x.... 0x....      BL       LedBlink
    121          
    122            /* Set an LED to the dimmest state we have (5% duty cycle) */
    123            LedPWM(WHITE, LED_PWM_5);
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       LedPWM
    124          
    125          } /* end UserApp1Initialize() */
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
    126          
    127            
    128          /*!----------------------------------------------------------------------------------------------------------------------
    129          @fn void UserApp1RunActiveState(void)
    130          
    131          @brief Selects and runs one iteration of the current state in the state machine.
    132          
    133          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    134          may take 1ms / n to execute.
    135          
    136          Requires:
    137          - State machine function pointer points at current state
    138          
    139          Promises:
    140          - Calls the function to pointed by the state machine function pointer
    141          
    142          */

   \                                 In section .text, align 2, keep-with-next
    143          void UserApp1RunActiveState(void)
    144          {
   \                     UserApp1RunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    145            UserApp1_pfStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable2_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    146          
    147          } /* end UserApp1RunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    148          
    149          
    150          /*------------------------------------------------------------------------------------------------------------------*/
    151          /*! @privatesection */                                                                                            
    152          /*--------------------------------------------------------------------------------------------------------------------*/
    153          
    154          
    155          /**********************************************************************************************************************
    156          State Machine Function Definitions
    157          **********************************************************************************************************************/
    158          /*-------------------------------------------------------------------------------------------------------------------*/
    159          /* What does this state do? */

   \                                 In section .text, align 4, keep-with-next
    160          static void UserApp1SM_Idle(void)
    161          {
   \                     UserApp1SM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    162            static u8 u8BinaryCounter = 0;
    163            static u16 u16counter = 0;
    164            /*increment counter*/
    165            u16counter++;
   \   00000002   0x....             LDR.N    R0,??DataTable2_2
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable2_2
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
    166            
    167            /*if counter = 500 toggle led and roll over*/
    168            if(u16counter == LED_limit){
   \   0000000C   0x....             LDR.N    R0,??DataTable2_2
   \   0000000E   0x8800             LDRH     R0,[R0, #+0]
   \   00000010   0xF5B0 0x7FFA      CMP      R0,#+500
   \   00000014   0xD111             BNE.N    ??UserApp1SM_Idle_0
    169              
    170            LedToggle(BLUE);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       LedToggle
    171            u16counter = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x....             LDR.N    R1,??DataTable2_2
   \   00000020   0x8008             STRH     R0,[R1, #+0]
    172            u8BinaryCounter++;
   \   00000022   0x....             LDR.N    R0,??DataTable2_3
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0x....             LDR.N    R1,??DataTable2_3
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    173            
    174              if(u8BinaryCounter == 16){
   \   0000002C   0x....             LDR.N    R0,??DataTable2_3
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2810             CMP      R0,#+16
   \   00000032   0xD102             BNE.N    ??UserApp1SM_Idle_0
    175                u8BinaryCounter = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR.N    R1,??DataTable2_3
   \   00000038   0x7008             STRB     R0,[R1, #+0]
    176              }
    177              
    178            }
    179            
    180            
    181          
    182              
    183              /* All discrete LEDs to off */
    184            LedOff(WHITE);
   \                     ??UserApp1SM_Idle_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       LedOff
    185            LedOff(PURPLE);
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       LedOff
    186            LedOff(BLUE);
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      BL       LedOff
    187            LedOff(CYAN);
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0x.... 0x....      BL       LedOff
    188            LedOff(GREEN);
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0x.... 0x....      BL       LedOff
    189            LedOff(YELLOW);
   \   00000058   0x2005             MOVS     R0,#+5
   \   0000005A   0x.... 0x....      BL       LedOff
    190            LedOff(ORANGE);
   \   0000005E   0x2006             MOVS     R0,#+6
   \   00000060   0x.... 0x....      BL       LedOff
    191            LedOff(RED);
   \   00000064   0x2007             MOVS     R0,#+7
   \   00000066   0x.... 0x....      BL       LedOff
    192            
    193            /* Backlight to white */  
    194            LedOn(LCD_RED);
   \   0000006A   0x2008             MOVS     R0,#+8
   \   0000006C   0x.... 0x....      BL       LedOn
    195            LedOn(LCD_GREEN);
   \   00000070   0x2009             MOVS     R0,#+9
   \   00000072   0x.... 0x....      BL       LedOn
    196            LedOn(LCD_BLUE);
   \   00000076   0x200A             MOVS     R0,#+10
   \   00000078   0x.... 0x....      BL       LedOn
    197            
    198          } /* end UserApp1SM_Idle() */
   \   0000007C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 1
   \                     `UserApp1SM_Idle::u8BinaryCounter`:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
   \                     `UserApp1SM_Idle::u16counter`:
   \   00000000                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x400E0C30         DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     UserApp1_pfStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     `UserApp1SM_Idle::u16counter`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     `UserApp1SM_Idle::u8BinaryCounter`
    199               
    200          
    201          /*-------------------------------------------------------------------------------------------------------------------*/
    202          /* Handle an error */
    203          static void UserApp1SM_Error(void)          
    204          {
    205          
    206          } /* end UserApp1SM_Error() */
    207          
    208          
    209          
    210          
    211          /*--------------------------------------------------------------------------------------------------------------------*/
    212          /* End of File                                                                                                        */
    213          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UserApp1Initialize
         8   -> LedBlink
         8   -> LedOff
         8   -> LedOn
         8   -> LedPWM
       8   UserApp1RunActiveState
         8   -- Indirect call
       8   UserApp1SM_Idle
         8   -> LedOff
         8   -> LedOn
         8   -> LedToggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  G_u32UserApp1Flags
      72  UserApp1Initialize
      10  UserApp1RunActiveState
     126  UserApp1SM_Idle
       4  UserApp1_pfStateMachine
       2  u16counter
       1  u8BinaryCounter

 
  11 bytes in section .bss
 224 bytes in section .text
 
 224 bytes of CODE memory
  11 bytes of DATA memory

Errors: none
Warnings: none
