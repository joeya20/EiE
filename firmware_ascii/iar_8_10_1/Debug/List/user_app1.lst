###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       24/Nov/2019  15:32:38
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Github\EiE\firmware_common\application\user_app1.c
#    Command line =  
#        -f C:\Users\JoeyD\AppData\Local\Temp\EW5449.tmp
#        (C:\Github\EiE\firmware_common\application\user_app1.c -D EIE_ASCII
#        --preprocess=cs C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\List -lC
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\List -o
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\bsp\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\drivers\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\application\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\ -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\application\
#        -I C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\bsp\
#        -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\List\user_app1.lst
#    Object file  =  
#        C:\Github\EiE\firmware_ascii\iar_8_10_1\Debug\Obj\user_app1.o
#
###############################################################################

C:\Github\EiE\firmware_common\application\user_app1.c
      1          /*!*********************************************************************************************************************
      2          @file user_app1.c                                                                
      3          @brief User's tasks / applications are written here.  This description
      4          should be replaced by something specific to the task.
      5          
      6          ----------------------------------------------------------------------------------------------------------------------
      7          To start a new task using this user_app1 as a template:
      8           1. Copy both user_app1.c and user_app1.h to the Application directory
      9           2. Rename the files yournewtaskname.c and yournewtaskname.h
     10           3. Add yournewtaskname.c and yournewtaskname.h to the Application Include and Source groups in the IAR project
     11           4. Use ctrl-h (make sure "Match Case" is checked) to find and replace all instances of "user_app1" with "yournewtaskname"
     12           5. Use ctrl-h to find and replace all instances of "UserApp1" with "YourNewTaskName"
     13           6. Use ctrl-h to find and replace all instances of "USER_APP1" with "YOUR_NEW_TASK_NAME"
     14           7. Add a call to YourNewTaskNameInitialize() in the init section of main
     15           8. Add a call to YourNewTaskNameRunActiveState() in the Super Loop section of main
     16           9. Update yournewtaskname.h per the instructions at the top of yournewtaskname.h
     17          10. Include new header file in "configuration.h"
     18          11. Delete this text (between the dashed lines) and update the Description below to describe your task
     19          ----------------------------------------------------------------------------------------------------------------------
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          GLOBALS
     23          -NONE
     24          
     25          CONSTANTS
     26          - NONE
     27          
     28          TYPES
     29          - NONE
     30          
     31          PUBLIC FUNCTIONS
     32          - NONE
     33          
     34          PROTECTED FUNCTIONS
     35          - void UserApp1Initialize(void)
     36          - void UserApp1RunActiveState(void)
     37          
     38          
     39          **********************************************************************************************************************/
     40          
     41          #include "configuration.h"
     42          
     43          /***********************************************************************************************************************
     44          Global variable definitions with scope across entire project.
     45          All Global variable names shall start with "G_<type>UserApp1"
     46          ***********************************************************************************************************************/
     47          /* New variables */

   \                                 In section .bss, align 4
     48          volatile u32 G_u32UserApp1Flags;                          /*!< @brief Global state flags */
   \                     G_u32UserApp1Flags:
   \   00000000                      DS8 4
     49          
     50          
     51          /*--------------------------------------------------------------------------------------------------------------------*/
     52          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     53          extern volatile u32 G_u32SystemTime1ms;                   /*!< @brief From main.c */
     54          extern volatile u32 G_u32SystemTime1s;                    /*!< @brief From main.c */
     55          extern volatile u32 G_u32SystemFlags;                     /*!< @brief From main.c */
     56          extern volatile u32 G_u32ApplicationFlags;                /*!< @brief From main.c */
     57          
     58          
     59          /***********************************************************************************************************************
     60          Global variable definitions with scope limited to this local application.
     61          Variable names shall start with "UserApp1_<type>" and be declared as static.
     62          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     63          static fnCode_type UserApp1_pfStateMachine;               /*!< @brief The state machine function pointer */
   \                     UserApp1_pfStateMachine:
   \   00000000                      DS8 4
     64          //static u32 UserApp1_u32Timeout;                           /*!< @brief Timeout counter used across states */
     65          
     66          
     67          /**********************************************************************************************************************
     68          Function Definitions
     69          **********************************************************************************************************************/
     70          
     71          /*--------------------------------------------------------------------------------------------------------------------*/
     72          /*! @publicsection */                                                                                            
     73          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     74          ButtonNameType ButtonPressed(void)
     75          {
   \                     ButtonPressed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     76            ButtonNameType eTheButton = NOBUTTON;
   \   00000002   0x2404             MOVS     R4,#+4
     77            
     78            if(WasButtonPressed(BUTTON0))
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       WasButtonPressed
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??ButtonPressed_0
     79            {
     80              ButtonAcknowledge(BUTTON0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       ButtonAcknowledge
     81              eTheButton = BUTTON0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0004             MOVS     R4,R0
     82            }
     83            if(WasButtonPressed(BUTTON1))
   \                     ??ButtonPressed_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x.... 0x....      BL       WasButtonPressed
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ.N    ??ButtonPressed_1
     84            {
     85              ButtonAcknowledge(BUTTON1);
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       ButtonAcknowledge
     86              eTheButton = BUTTON1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x0004             MOVS     R4,R0
     87            }
     88            if(WasButtonPressed(BUTTON2))
   \                     ??ButtonPressed_1: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x.... 0x....      BL       WasButtonPressed
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD004             BEQ.N    ??ButtonPressed_2
     89            {
     90              ButtonAcknowledge(BUTTON2);
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x.... 0x....      BL       ButtonAcknowledge
     91              eTheButton = BUTTON2;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x0004             MOVS     R4,R0
     92            }
     93            if(WasButtonPressed(BUTTON3))
   \                     ??ButtonPressed_2: (+1)
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x.... 0x....      BL       WasButtonPressed
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD004             BEQ.N    ??ButtonPressed_3
     94            {
     95              ButtonAcknowledge(BUTTON3);
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0x.... 0x....      BL       ButtonAcknowledge
     96              eTheButton = BUTTON3;
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0x0004             MOVS     R4,R0
     97            }
     98            return eTheButton;
   \                     ??ButtonPressed_3: (+1)
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
     99              
    100          }
    101          /*--------------------------------------------------------------------------------------------------------------------*/
    102          /*! @protectedsection */                                                                                            
    103          /*--------------------------------------------------------------------------------------------------------------------*/
    104          
    105          /*!--------------------------------------------------------------------------------------------------------------------
    106          @fn void UserApp1Initialize(void)
    107          
    108          @brief
    109          Initializes the State Machine and its variables.
    110          
    111          Should only be called once in main init section.
    112          
    113          Requires:
    114          - NONE
    115          
    116          Promises:
    117          - NONE
    118          
    119          */

   \                                 In section .text, align 2, keep-with-next
    120          void UserApp1Initialize(void)
    121          {
   \                     UserApp1Initialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    122            HEARTBEAT_OFF();
   \   00000004   0xF05F 0x4000      MOVS     R0,#-2147483648
   \   00000008   0x....             LDR.N    R1,??DataTable3  ;; 0x400e0c30
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    123            /* If good initialization, set state to Idle */
    124            if( 1 )
    125            {
    126              u8 au8Message[] = "Enter a combination of 4 buttons.";
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x....             LDR.N    R1,??DataTable3_1
   \   00000010   0x2222             MOVS     R2,#+34
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    127              LcdMessage(LINE1_START_ADDR, au8Message);
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       LcdMessage
    128              UserApp1_pfStateMachine = UserApp1SM_Idle;
   \   0000001E   0x.... 0x....      ADR.W    R0,UserApp1SM_Idle
   \   00000022   0x....             LDR.N    R1,??DataTable3_2
   \   00000024   0x6008             STR      R0,[R1, #+0]
    129            }
    130            else
    131            {
    132              /* The task isn't properly initialized, so shut it down and don't run */
    133              UserApp1_pfStateMachine = UserApp1SM_Error;
    134            }
    135          
    136          } /* end UserApp1Initialize() */
   \   00000026   0xB009             ADD      SP,SP,#+36
   \   00000028   0xBD00             POP      {PC}             ;; return
    137          
    138            
    139          /*!----------------------------------------------------------------------------------------------------------------------
    140          @fn void UserApp1RunActiveState(void)
    141          
    142          @brief Selects and runs one iteration of the current state in the state machine.
    143          
    144          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    145          may take 1ms / n to execute.
    146          
    147          Requires:
    148          - State machine function pointer points at current state
    149          
    150          Promises:
    151          - Calls the function to pointed by the state machine function pointer
    152          
    153          */

   \                                 In section .text, align 2, keep-with-next
    154          void UserApp1RunActiveState(void)
    155          {
   \                     UserApp1RunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    156            UserApp1_pfStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable3_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    157          
    158          } /* end UserApp1RunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    159          
    160          
    161          /*------------------------------------------------------------------------------------------------------------------*/
    162          /*! @privatesection */                                                                                            
    163          /*--------------------------------------------------------------------------------------------------------------------*/
    164          
    165          
    166          /**********************************************************************************************************************
    167          State Machine Function Definitions
    168          **********************************************************************************************************************/
    169          /*-------------------------------------------------------------------------------------------------------------------*/
    170          /* What does this state do? */

   \                                 In section .text, align 4, keep-with-next
    171          static void UserApp1SM_Idle(void)
    172          {
   \                     UserApp1SM_Idle: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
    173            static u8 right = 0;
    174            static u8 attempt = 0;
    175            ButtonNameType eTheButton = NOBUTTON;
   \   00000002   0x2404             MOVS     R4,#+4
    176            bool CODE = FALSE;
   \   00000004   0x2500             MOVS     R5,#+0
    177            u8 au8Correct[] = "Lock Open.";
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x....             LDR.N    R1,??DataTable3_3
   \   0000000A   0x220B             MOVS     R2,#+11
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    178            //u8 au8Wrong[] = "Lock Closed.";
    179            if(!CODE)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD105             BNE.N    ??UserApp1SM_Idle_0
    180            {
    181            LedOn(RED);
   \   00000016   0x2007             MOVS     R0,#+7
   \   00000018   0x.... 0x....      BL       LedOn
    182            LedOff(GREEN);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       LedOff
    183            }
    184            eTheButton = ButtonPressed();
   \                     ??UserApp1SM_Idle_0: (+1)
   \   00000022   0x.... 0x....      BL       ButtonPressed
   \   00000026   0x0004             MOVS     R4,R0
    185            
    186            if(eTheButton == BUTTON0 && attempt ==0)
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD10D             BNE.N    ??UserApp1SM_Idle_1
   \   0000002E   0x....             LDR.N    R0,??DataTable3_4
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD109             BNE.N    ??UserApp1SM_Idle_1
    187            {
    188            attempt++; 
   \   00000036   0x....             LDR.N    R0,??DataTable3_4
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable3_4
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    189            right++;
   \   00000040   0x....             LDR.N    R0,??DataTable3_5
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x....             LDR.N    R1,??DataTable3_5
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    190            }
    191          
    192            if(eTheButton == BUTTON1 && attempt ==1)
   \                     ??UserApp1SM_Idle_1: (+1)
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x2C01             CMP      R4,#+1
   \   0000004E   0xD10D             BNE.N    ??UserApp1SM_Idle_2
   \   00000050   0x....             LDR.N    R0,??DataTable3_4
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD109             BNE.N    ??UserApp1SM_Idle_2
    193            {
    194            attempt++; 
   \   00000058   0x....             LDR.N    R0,??DataTable3_4
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x....             LDR.N    R1,??DataTable3_4
   \   00000060   0x7008             STRB     R0,[R1, #+0]
    195            right++;
   \   00000062   0x....             LDR.N    R0,??DataTable3_5
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable3_5
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    196            }
    197            
    198            if(eTheButton == BUTTON2 && attempt ==2)
   \                     ??UserApp1SM_Idle_2: (+1)
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x2C02             CMP      R4,#+2
   \   00000070   0xD10D             BNE.N    ??UserApp1SM_Idle_3
   \   00000072   0x....             LDR.N    R0,??DataTable3_4
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x2802             CMP      R0,#+2
   \   00000078   0xD109             BNE.N    ??UserApp1SM_Idle_3
    199            {
    200            attempt++; 
   \   0000007A   0x....             LDR.N    R0,??DataTable3_4
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x1C40             ADDS     R0,R0,#+1
   \   00000080   0x....             LDR.N    R1,??DataTable3_4
   \   00000082   0x7008             STRB     R0,[R1, #+0]
    201            right++;
   \   00000084   0x....             LDR.N    R0,??DataTable3_5
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x....             LDR.N    R1,??DataTable3_5
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    202            }
    203            
    204            if(eTheButton == BUTTON3 && attempt ==3)
   \                     ??UserApp1SM_Idle_3: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C03             CMP      R4,#+3
   \   00000092   0xD10D             BNE.N    ??UserApp1SM_Idle_4
   \   00000094   0x....             LDR.N    R0,??DataTable3_4
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x2803             CMP      R0,#+3
   \   0000009A   0xD109             BNE.N    ??UserApp1SM_Idle_4
    205            {
    206            attempt++; 
   \   0000009C   0x....             LDR.N    R0,??DataTable3_4
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0x....             LDR.N    R1,??DataTable3_4
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    207            right++;
   \   000000A6   0x....             LDR.N    R0,??DataTable3_5
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0x....             LDR.N    R1,??DataTable3_5
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
    208            }
    209            
    210            if(right == CODESIZE)
   \                     ??UserApp1SM_Idle_4: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable3_5
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0x2804             CMP      R0,#+4
   \   000000B6   0xD101             BNE.N    ??UserApp1SM_Idle_5
    211              CODE = TRUE;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x0005             MOVS     R5,R0
    212            
    213            if(CODE == TRUE)
   \                     ??UserApp1SM_Idle_5: (+1)
   \   000000BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BE   0x2D01             CMP      R5,#+1
   \   000000C0   0xD10C             BNE.N    ??UserApp1SM_Idle_6
    214            {
    215              LedOff(RED);
   \   000000C2   0x2007             MOVS     R0,#+7
   \   000000C4   0x.... 0x....      BL       LedOff
    216              LedOn(GREEN);
   \   000000C8   0x2004             MOVS     R0,#+4
   \   000000CA   0x.... 0x....      BL       LedOn
    217              LcdCommand(LCD_CLEAR_CMD);
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x.... 0x....      BL       LcdCommand
    218              LcdMessage(LINE1_START_ADDR, au8Correct);
   \   000000D4   0x4669             MOV      R1,SP
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x.... 0x....      BL       LcdMessage
    219            }
    220          } /* end UserApp1SM_Idle() */
   \                     ??UserApp1SM_Idle_6: (+1)
   \   000000DC   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .bss, align 1
   \                     `UserApp1SM_Idle::right`:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     `UserApp1SM_Idle::attempt`:
   \   00000000                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x400E0C30         DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     UserApp1_pfStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     `UserApp1SM_Idle::attempt`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     `UserApp1SM_Idle::right`

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x6E          DC8 "Enter a combination of 4 buttons."
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x61 0x20    
   \              0x63 0x6F    
   \              0x6D 0x62    
   \              0x69 0x6E    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x6F 0x66    
   \              0x20 0x34    
   \              0x20 0x62    
   \              0x75 0x74    
   \              0x74 0x6F    
   \              0x6E 0x73    
   \              0x2E 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x4C 0x6F          DC8 "Lock Open."
   \              0x63 0x6B    
   \              0x20 0x4F    
   \              0x70 0x65    
   \              0x6E 0x2E    
   \              0x00         
   \   0000000B   0x00               DC8 0
    221               
    222          
    223          /*-------------------------------------------------------------------------------------------------------------------*/
    224          /* Handle an error */
    225          static void UserApp1SM_Error(void)          
    226          {
    227          
    228          } /* end UserApp1SM_Error() */
    229          
    230          
    231          
    232          
    233          /*--------------------------------------------------------------------------------------------------------------------*/
    234          /* End of File                                                                                                        */
    235          /*--------------------------------------------------------------------------------------------------------------------*/
    236          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ButtonPressed
         8   -> ButtonAcknowledge
         8   -> WasButtonPressed
      40   UserApp1Initialize
        40   -> LcdMessage
        40   -> __aeabi_memcpy
       8   UserApp1RunActiveState
         8   -- Indirect call
      24   UserApp1SM_Idle
        24   -> ButtonPressed
        24   -> LcdCommand
        24   -> LcdMessage
        24   -> LedOff
        24   -> LedOn
        24   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
      36  ?_0
      12  ?_1
      90  ButtonPressed
       4  G_u32UserApp1Flags
      42  UserApp1Initialize
      10  UserApp1RunActiveState
     222  UserApp1SM_Idle
       4  UserApp1_pfStateMachine
       1  attempt
       1  right

 
  10 bytes in section .bss
  48 bytes in section .rodata
 388 bytes in section .text
 
 388 bytes of CODE  memory
  48 bytes of CONST memory
  10 bytes of DATA  memory

Errors: none
Warnings: none
